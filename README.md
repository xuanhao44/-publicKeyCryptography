# rsa

学校的 rsa 实验

## 项目结构

主要部分

```ascii
rsa
│  README.md
│         
├─data
│  ├─inData
│  │      lab2-Plaintext.txt
│  │      
│  └─outData
│          lab2-Decrypt-text.txt
│          lab2-Encrypt-text.txt
│                      
├─src
│  └─edu
│      └─rsa
│              RSA.java
│              RSAUtils.java
│              SelfUtils.java
│              
└─test
    └─edu
        └─rsa
                RSAUtilsTest.java
                SelfUtilsTest.java
```

## 运行结果

n = 10 的示例

```ascii
p = 17977, len(p) = 15
q = 23, len(q) = 5
n = 413471, len(n) = 19
phiN = 395472, len(phiN) = 19
e = 491, len(e) = 9
gcd(e, phiN) = 1
d = 180419, len(d) = 18
e * d mod phiN = 1
e * d - 1 = 88585728
(e * d - 1) / phi_N = 224
```

n = 1024 的示例

```shell
p = 3828281911187973009199499145938687251826186747748746884223212089985541092642931283863902965847605791753152803524761759267647713539818562237054218812986360569990779142705539322536418452533501028196928107637812460700693407366269984526425010696152772057857725365935872098205520243162057340482187491446438150927387, len(p) = 1029
q = 3886258568146491055175613596261941209610177424189010183513868748218090979073006322681272411980832069178667294924286428248610978694956790054995287969130774131510033077760327631364588608769279248823275786407140265663627488272189568724261749268117102491514102100086332230839398043719245083249812281450830310783, len(q) = 1019
n = 14877693378634484222233937200570322437083853754386056072786037865896309320764489934047143952759595011941396887064215029343581165723113484164528947879757953795839158413249993774587129371708010626197995030433731444730630381867753520527178890380189787436853306978515404050355302849167930411516866915393641975025141353007171613574406934924350551002225579055363555292414405600584078557310281965811990180854474856864897500761532930789402838951677544404860601523965859304274013327838816696444418923740605963265858437861842503770061595756735739881679392777074704452696144742548698008549419372929727441186677620728740876114021, len(n) = 2047
phiN = 14877693378634484222233937200570322437083853754386056072786037865896309320764489934047143952759595011941396887064215029343581165723113484164528947879757953795839158413249993774587129371708010626197995030433731444730630381867753520527178890380189787436853306978515404050355302849167930411516866915393641975021309184837415494074152260164815601809189782130190619398007679641850319373688277675625405942594888233042566029941846885093506514433164025377751387423010367960151724152055517046276635882598335655820107054437622902803704560902193565786530120331653815292346905274512739578113059731723950855621240317000851894875852, len(phiN) = 2047
e = 112745749727580707611018538211800349708436743360028736057947264101165383946090786265033963027012044144486885567897819060337111993487051561101533394070878120285124115041197631497184147378339978501394348072307128181487834747723744179881642370432914784416159842908937453007973277936430645041461195462557877808941, len(e) = 1024
gcd(e, phiN) = 1
d = 1618620896693938008007363000833465298309719260188849347988446922948461647016558967193414463892768748047805597092999915755971526737331110303704456248570482546119612523893351542691456783125587733021700948131755768781349294414410518105015613814332308570661932472956833562121627420027451274399747365627959583850575750298707391247292498234258922877758227514908991056067028857910274252579006253998712134775415659960626098501126166760398995200836706877741080860544678141525463938451247843744414878465041531815053916549936019777485730170429838939305756965431880091592802171094639189381089149205411604002083345386456599458005, len(d) = 2044
e * d mod phiN = 1
e * d - 1 = 182492626522487001842914891741029009755942770047093117510336725207716797379791126133025806377073163670600202433899385893110990756092677932465998172436168151060575368714702236848574989361005433509325948287966100661812925617772538812801369385537455218502804512141724806720287748557293145378370117426093657835169454072170842986512790452951128694833295727825980746742225125197807440173221944767825693966979062995252507948453596190423754710583664266878381131974989076130138866523990944055184134993589616888450520848526915179319006631627001223723527605864895185478450335482834657179345594048015128693611257658681398285241553575920323990650835922051820348189502061909501391219531618334170043278159165655403339261216338400469556109275857050902354469138856249957264297912310173151669568765085735670238406970044570889277131737235554059432804037082962091106303370804573877424870693794351011331275322414744164456652314174731477543022704
(e * d - 1) / phi_N = 12266190858897555730768082103452744553613386725312016634331397334169421784380179076676064625471079493938960537070532577130656772208890617126224606594497432067268462047402723454244691703486827370513171465341856242651661700200992578645934087568503269335402197838120203194592339065773054479724434958855683579252
```

## 实验遇到的问题

1. 一开始不知道不能调库，去网上了解了一下 RSA 相关的库，还涉及到 Base64 编码，写好了才听老师说不可以用。解决办法是自己写一个。
2. 指导书上介绍的编码方式是不对的。解决办法是自己设计编码。
3. py 不太熟悉，开始写实验的时候比较头疼。解决办法是用熟悉的 Java 写。

## 字符分组方式

- 从文件读入待加密的明文

就算是可打印的 ASCII 编码，十进制表示编码的话也达到了三位数，如 z 编码是 122。

故而如果一次读入两个字符的话，需要将其转化为最高为 6 位的十进制数。

- 每次读入两个 byte, 如 a, b；
- ascii 码为 97 98；
- 将其组合为 097098 的 最高为 6 位的十进制数。

如果最后没有读满两个字符的话，就用 000 补足。

**（from in file）明文字符序列 -> 明文编码序列，其中的元素是最高为 6 位的十进制数；映射是 ASCII。**

- 加密

明文分组的长度是远小于 nLength 的，但密文分组长度 <= nLength，并且这个分组长度不是固定的。

**明文编码序列 -> 密文编码序列**

- 写入密文文件

上面说到，密文分组长度 <= nLength 且不固定。考虑到之后读入密文文件，我们需要在写入密文文件时对密文分组补充长度至
nLength。补充的方法是在密文分组前补充相应数量的 0。

写入密文文件的是所有补充完前导 0 的十进制密文分组的字符串，这里就不需要再转化成 UTF-8 或者 ASCII 了。

**密文编码序列 -> 补充完前导 0 的十进制密文分组的字符串序列 -> 密文字符序列（to en file）**

- 读入密文文件

一次读入 nLength 长度的字符数组，去掉前导 0，重新变为十进制密文分组，直到读完。

**（from en file）密文字符序列 -> 密文编码序列**

- 解密

**密文编码序列 -> 明文编码序列**

- 写入解密文件

按照最开始的编码方式解码。

把每一个解密明文分组，也就是最高为 6 位的十进制数，重新拆分为两个十进制数，转换为两个字符。最后如果有 000 就忽略。

**解密得到的明文编码序列 -> 明文字符序列（to de file）**

## 算法

大致复习 RSA

参数：

需要两个大素数 p，q

得到大素数乘积 n，其欧拉函数值 phi_n

找到一个小于 phi_n 的，且和 phi_n 互素（最大公因数为 1）的 e

求出 e 的逆元 d（模 phi_N 意义下）

加密：

c = m^e mod n

解密：

d = c^d mod n

所以需要以下算法：

生成大素数（参数是素数长度）：Miller-Rabin 算法

求最大公因数：欧几里得算法

求模逆元：拓展欧几里得算法

快速模幂：用到了同余性质，以及平方求幂。还可以用 CRT(Chinese Remainder Theorem)

## java 实现

很幸运的是 java 里 BigInteger 类包含了上面提到的所有算法。（乐）

当然也可以自己实现。我个人的实现放在 SelfUtils.java 中。虽然并未实际使用，但是结合标准实现做了自动化测试。

## 更多

想要补充更多攻击部分代码。